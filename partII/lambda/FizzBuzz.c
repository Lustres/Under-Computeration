#define I (lambda x: x)
#define K (lambda x: lambda y: x)
#define S (lambda x: lambda y: lambda z: x(z)(y(z)))
#define B (lambda x: lambda y: lambda z: x(y(z)))
#define C (lambda x: lambda y: lambda z: x(z(y)))
#define W (lambda x: lambda y: x(y)(y))
#define U (lambda x: lambda y: y(x(x)(y)))
#define ω (lambda x: x(x))
#define Ω (ω(ω))
#define Y (lambda g: (lambda x: g(x(x)))(lambda x: g(x(x))))
#define Z (lambda g: (lambda x: g(lambda y: x(x)(y)))(lambda x: g(lambda y: x(x)(y))))
#define ZERO (lambda p: lambda x: x)
#define ONE (lambda p: lambda x: p(x))
#define TWO (lambda p: lambda x: p(p(x)))
#define THREE (lambda p: lambda x: p(p(p(x))))
#define FOUR (lambda p: lambda x: p(p(p(p(x)))))
#define FIVE (lambda p: lambda x: p(p(p(p(p(x))))))
#define TEN (lambda p: lambda x: p(p(p(p(p(p(p(p(p(p(x)))))))))))
#define FIFTEEN (lambda p: lambda x: p(p(p(p(p(p(p(p(p(p(p(p(p(p(p(x))))))))))))))))
#define TRUE (lambda x: lambda y: x)
#define FALSE (lambda x: lambda y: y)
#define IF (lambda b: b)
#define AND (lambda x: lambda y: x(y)(x))
#define OR (lambda x: lambda y: x(x)(y))
#define NOT (lambda x: x(FALSE)(TRUE))
#define IS_ZERO (lambda l: l(lambda n: FALSE)(TRUE))
#define LESS_OR_EQUAL (lambda m: lambda n: IS_ZERO(SUB(m)(n)))
#define INCREMENT (lambda n: lambda p: lambda x: p(n(p)(x)))
#define DECREMENT (lambda n: LEFT(n(SLIDE)(PAIR(ZERO)(ZERO))))
#define ADD (lambda m: lambda n: lambda f: lambda x: m(f)(n(f)(x)))
#define SUB (lambda m: lambda n: n(DECREMENT)(m))
#define MULTI (lambda m: lambda n: lambda f: m(n(f)))
#define DIV Z(lambda f: lambda m: lambda n: IF(LESS_OR_EQUAL(n)(m))(lambda x: INCREMENT(f(SUB(m)(n))(n))(x))(ZERO))
#define POWER (lambda b: lambda e: e(b))
#define MOD Z(lambda f: lambda m: lambda n: IF(LESS_OR_EQUAL(n)(m))(lambda x: f(SUB(m)(n))(n)(x))(m))
#define PAIR (lambda x: lambda y: lambda f: f(x)(y))
#define LEFT (lambda f: f(TRUE))
#define RIGHT (lambda f: f(FALSE))
#define EMPTY PAIR(TRUE)(TRUE)
#define IS_EMPTY LEFT
#define UNSHIFT (lambda l: lambda x: PAIR(FALSE)(PAIR(x)(l)))
#define PUSH (lambda l: lambda x: FOLD(l)(UNSHIFT(EMPTY)(x))(UNSHIFT))
#define FIRST (lambda l: LEFT(RIGHT(l)))
#define REST (lambda l: RIGHT(RIGHT(l)))
#define SLIDE (lambda p: PAIR(RIGHT(p))(INCREMENT(RIGHT(p))))
#define RANGE Z(lambda f: lambda m: lambda n: IF(LESS_OR_EQUAL(m)(n))(lambda x: UNSHIFT(f(INCREMENT(m))(n))(m)(x))(EMPTY))
#define FOLD Z(lambda f: lambda l: lambda x: lambda g: IF(IS_EMPTY(l))(x)(lambda y: g(f(REST(l))(x)(g))(FIRST(l))(y)))
#define MAP (lambda k: lambda f: FOLD(k)(EMPTY)(lambda l: lambda x: UNSHIFT(l)(f(x))))
#define FIZZ UNSHIFT(UNSHIFT(UNSHIFT(UNSHIFT(EMPTY)(ADD(TEN)(FOUR)))(ADD(TEN)(FOUR)))(ADD(TEN)(TWO)))(ADD(TEN)(ONE))
#define BUZZ UNSHIFT(UNSHIFT(UNSHIFT(UNSHIFT(EMPTY)(ADD(TEN)(FOUR)))(ADD(TEN)(FOUR)))(ADD(TEN)(THREE)))(ADD(TEN)(ZERO))
#define FIZZBUZZ UNSHIFT(UNSHIFT(UNSHIFT(UNSHIFT(BUZZ)(ADD(TEN)(FOUR)))(ADD(TEN)(FOUR)))(ADD(TEN)(TWO)))(ADD(TEN)(ONE))
#define DIGITS Z(lambda f: lambda n: PUSH(IF(LESS_OR_EQUAL(n)(SUB(TEN)(ONE)))(EMPTY)(lambda x: f(DIV(n)(TEN))(x)))(MOD(n)(TEN)))
MAP(RANGE(ONE)(POWER(TEN)(TWO)))(lambda n: IF(IS_ZERO(MOD(n)(FIFTEEN)))(FIZZBUZZ)(IF(IS_ZERO(MOD(n)(THREE)))(FIZZ)(IF(IS_ZERO(MOD(n)(FIVE)))(BUZZ)(DIGITS(n)))))
